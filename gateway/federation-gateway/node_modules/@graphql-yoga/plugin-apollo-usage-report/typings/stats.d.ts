import type { NonFtv1ErrorPath } from '@apollo/server-gateway-interface';
import { Trace, type google, type IContextualizedStats, type IFieldStat, type IPathErrorStats, type IQueryLatencyStats, type IReport, type IStatsContext, type ITracesAndStats, type ITypeStat, type ReportHeader } from '@apollo/usage-reporting-protobuf';
import type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';
export declare class SizeEstimator {
    bytes: number;
}
export declare class OurReport implements Required<IReport> {
    readonly header: ReportHeader;
    tracesPreAggregated: boolean;
    constructor(header: ReportHeader);
    readonly tracesPerQuery: Record<string, OurTracesAndStats>;
    endTime: google.protobuf.ITimestamp | null;
    operationCount: number;
    readonly sizeEstimator: SizeEstimator;
    ensureCountsAreIntegers(): void;
    addTrace({ statsReportKey, trace, asTrace, referencedFieldsByType, maxTraceBytes, nonFtv1ErrorPaths, }: {
        statsReportKey: string;
        trace: Trace;
        asTrace: boolean;
        referencedFieldsByType: ReferencedFieldsByType;
        maxTraceBytes?: number;
        nonFtv1ErrorPaths: NonFtv1ErrorPath[];
    }): void;
    private getTracesAndStats;
}
declare class OurTracesAndStats implements Required<ITracesAndStats> {
    readonly referencedFieldsByType: ReferencedFieldsByType;
    constructor(referencedFieldsByType: ReferencedFieldsByType);
    readonly trace: Uint8Array[];
    readonly statsWithContext: StatsByContext;
    readonly internalTracesContributingToStats: Uint8Array[];
    ensureCountsAreIntegers(): void;
}
declare class StatsByContext {
    readonly map: {
        [k: string]: OurContextualizedStats;
    };
    /**
     * This function is used by the protobuf generator to convert this map into
     * an array of contextualized stats to serialize
     */
    toArray(): IContextualizedStats[];
    ensureCountsAreIntegers(): void;
    addTrace(trace: Trace, sizeEstimator: SizeEstimator, nonFtv1ErrorPaths: NonFtv1ErrorPath[]): void;
    private getContextualizedStats;
}
export declare class OurContextualizedStats implements Required<IContextualizedStats> {
    readonly context: IStatsContext;
    queryLatencyStats: OurQueryLatencyStats;
    perTypeStat: {
        [k: string]: OurTypeStat;
    };
    constructor(context: IStatsContext);
    ensureCountsAreIntegers(): void;
    addTrace(trace: Trace, sizeEstimator: SizeEstimator, nonFtv1ErrorPaths?: NonFtv1ErrorPath[]): void;
    getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat;
}
declare class OurQueryLatencyStats implements Required<IQueryLatencyStats> {
    latencyCount: DurationHistogram;
    requestCount: number;
    requestsWithoutFieldInstrumentation: number;
    cacheHits: number;
    persistedQueryHits: number;
    persistedQueryMisses: number;
    cacheLatencyCount: DurationHistogram;
    rootErrorStats: OurPathErrorStats;
    requestsWithErrorsCount: number;
    publicCacheTtlCount: DurationHistogram;
    privateCacheTtlCount: DurationHistogram;
    registeredOperationCount: number;
    forbiddenOperationCount: number;
}
declare class OurPathErrorStats implements Required<IPathErrorStats> {
    children: {
        [k: string]: OurPathErrorStats;
    };
    errorsCount: number;
    requestsWithErrorsCount: number;
    getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats;
}
declare class OurTypeStat implements Required<ITypeStat> {
    perFieldStat: {
        [k: string]: OurFieldStat;
    };
    getFieldStat(fieldName: string, returnType: string, sizeEstimator: SizeEstimator): OurFieldStat;
    ensureCountsAreIntegers(): void;
}
declare class OurFieldStat implements Required<IFieldStat> {
    readonly returnType: string;
    errorsCount: number;
    observedExecutionCount: number;
    estimatedExecutionCount: number;
    requestsWithErrorsCount: number;
    latencyCount: DurationHistogram;
    constructor(returnType: string);
    ensureCountsAreIntegers(): void;
}
export interface DurationHistogramOptions {
    initSize?: number;
    buckets?: number[];
}
export declare class DurationHistogram {
    private readonly buckets;
    static readonly BUCKET_COUNT = 384;
    static readonly EXPONENT_LOG: number;
    toArray(): number[];
    static durationToBucket(durationNs: number): number;
    incrementDuration(durationNs: number, value?: number): DurationHistogram;
    incrementBucket(bucket: number, value?: number): void;
    combine(otherHistogram: DurationHistogram): void;
    constructor(options?: DurationHistogramOptions);
}
/**
 * Iterates over the entire trace, calling `f` on each Trace.Node found. It
 * looks under the "root" node as well as any inside the query plan. If any `f`
 * returns true, it stops walking the tree.
 *
 * Each call to `f` will receive an object that implements ResponseNamePath. If
 * `includePath` is true, `f` can call `toArray()` on it to convert the
 * linked-list representation to an array of the response name (field name)
 * nodes that you navigate to get to the node (including a "service:subgraph"
 * top-level node if this is a federated trace). Note that we don't add anything
 * to the path for index (list element) nodes. This is because the only use case
 * we have (error path statistics) does not care about list indexes (it's not
 * that interesting to know that sometimes an error was at foo.3.bar and
 * sometimes foo.5.bar, vs just generally foo.bar).
 *
 * If `includePath` is false, we don't bother to build up the linked lists, and
 * calling `toArray()` will throw.
 */
export declare function iterateOverTrace(trace: Trace, f: (node: Trace.INode, path: ResponseNamePath) => boolean, includePath: boolean): void;
export interface ResponseNamePath {
    toArray(): string[];
    child(responseName: string): ResponseNamePath;
}
export {};
