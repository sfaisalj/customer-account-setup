"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cross_helpers_1 = require("@graphql-mesh/cross-helpers");
const redis_1 = require("@upstash/redis");
const disposablestack_1 = require("@whatwg-node/disposablestack");
class UpstashRedisCache {
    constructor(config) {
        this.abortCtrl = new AbortController();
        this.redis = new redis_1.Redis({
            url: cross_helpers_1.process.env.UPSTASH_REDIS_REST_URL,
            token: cross_helpers_1.process.env.UPSTASH_REDIS_REST_TOKEN,
            enableAutoPipelining: true,
            signal: this.abortCtrl.signal,
            latencyLogging: !!cross_helpers_1.process.env.DEBUG,
            ...config,
        });
    }
    get(key) {
        return this.redis.get(key);
    }
    set(key, value, options) {
        if (options?.ttl) {
            return this.redis.set(key, value, {
                px: options.ttl * 1000,
            });
        }
        else {
            return this.redis.set(key, value);
        }
    }
    delete(key) {
        return this.redis.del(key).then(num => num > 0);
    }
    async getKeysByPrefix(prefix) {
        const keys = [];
        let cursor = '0';
        do {
            const result = await this.redis.scan(cursor, {
                match: prefix + '*',
                count: 100,
            });
            cursor = result[0];
            keys.push(...result[1]);
        } while (cursor !== '0');
        return keys;
    }
    [disposablestack_1.DisposableSymbols.dispose]() {
        return this.abortCtrl.abort();
    }
}
exports.default = UpstashRedisCache;
