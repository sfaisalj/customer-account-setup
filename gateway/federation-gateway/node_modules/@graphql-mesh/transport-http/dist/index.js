import { process } from '@graphql-mesh/cross-helpers';
import { getInterpolatedHeadersFactory, getInterpolatedStringFactory } from '@graphql-mesh/string-interpolation';
import { makeAsyncDisposable, dispose, isDisposable } from '@graphql-mesh/utils';
import { buildHTTPExecutor } from '@graphql-tools/executor-http';
import { handleMaybePromise } from '@whatwg-node/promise-helpers';

var index = {
  getSubgraphExecutor(payload) {
    let headersInConfig;
    if (typeof payload.transportEntry.headers === "string") {
      headersInConfig = JSON.parse(payload.transportEntry.headers);
    }
    if (Array.isArray(payload.transportEntry.headers)) {
      headersInConfig = Object.fromEntries(payload.transportEntry.headers);
    }
    const headersFactory = headersInConfig ? getInterpolatedHeadersFactory(headersInConfig) : void 0;
    const endpointFactory = payload.transportEntry.location ? getInterpolatedStringFactory(payload.transportEntry.location) : void 0;
    const httpExecutor = buildHTTPExecutor({
      endpoint: endpointFactory ? (execReq) => endpointFactory({
        env: process.env,
        root: execReq?.rootValue,
        context: execReq?.context,
        info: execReq?.info
      }) : payload.transportEntry.location,
      headers: headersFactory ? (execReq) => headersFactory({
        env: process.env,
        root: execReq?.rootValue,
        context: execReq?.context,
        info: execReq?.info
      }) : void 0,
      ...payload.transportEntry.options,
      getDisposeReason: payload.getDisposeReason,
      // @ts-expect-error - TODO: Fix this in executor-http
      fetch: payload.fetch
    });
    if (payload.transportEntry.options && "subscriptions" in payload.transportEntry.options && payload.transportEntry.options.subscriptions != null) {
      let subscriptionsExecutor = function(execReq) {
        const subscriptionsKind = payload.transportEntry.options?.subscriptions?.kind || payload.transportEntry.kind;
        const subscriptionsLocation = payload.transportEntry.options?.subscriptions?.location ? new URL(
          payload.transportEntry.options.subscriptions.location,
          payload.transportEntry.location
        ).toString() : payload.transportEntry.location;
        return handleMaybePromise(
          () => payload.getTransportExecutor({
            ...payload.transportEntry,
            kind: subscriptionsKind,
            headers: (
              // WebSocket transport should not have any headers by default,
              // `connectionParams` should be preferred.
              subscriptionsKind === "ws" ? payload.transportEntry.options?.subscriptions?.headers : payload.transportEntry.options?.subscriptions?.headers ?? payload.transportEntry.headers
            ),
            location: subscriptionsLocation,
            options: {
              ...payload.transportEntry.options,
              ...payload.transportEntry.options?.subscriptions?.options,
              // Make sure to remove subscription option to avoid infinite loop.
              // This option doesn't make sense here but is present in `transportEntry.options`
              subscriptions: void 0
            }
          }),
          (resolvedSubscriptionsExecutor) => {
            subscriptionsExecutor = resolvedSubscriptionsExecutor;
            return subscriptionsExecutor(execReq);
          }
        );
      };
      return makeAsyncDisposable(
        function hybridExecutor(executionRequest) {
          if (subscriptionsExecutor && executionRequest.operationType === "subscription") {
            return subscriptionsExecutor(executionRequest);
          }
          return httpExecutor(executionRequest);
        },
        () => Promise.all([
          dispose(httpExecutor),
          isDisposable(subscriptionsExecutor) && dispose(subscriptionsExecutor)
        ]).then(() => {
        })
      );
    }
    return httpExecutor;
  }
};

export { index as default };
