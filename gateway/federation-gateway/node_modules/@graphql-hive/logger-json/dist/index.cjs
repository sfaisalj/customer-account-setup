'use strict';

var utils = require('@graphql-mesh/utils');
var crossInspect = require('cross-inspect');

function getEnvStr(key, opts = {}) {
  const globalThat = opts.globalThis ?? globalThis;
  let variable = globalThat.process?.env?.[key] || // @ts-expect-error can exist in wrangler and maybe other runtimes
  globalThat.env?.[key] || // @ts-expect-error can exist in deno
  globalThat.Deno?.env?.get(key) || // @ts-expect-error could be
  globalThat[key];
  if (variable != null) {
    variable += "";
  } else {
    variable = void 0;
  }
  return variable?.trim();
}

function truthy(val) {
  return val === true || val === 1 || ["1", "t", "true", "y", "yes"].includes(String(val));
}
class JSONLogger {
  name;
  meta;
  logLevel;
  console;
  constructor(opts) {
    this.name = opts?.name;
    this.console = opts?.console || console;
    this.meta = opts?.meta || {};
    const debugStrs = [getEnvStr("DEBUG"), globalThis.DEBUG];
    if (opts?.level != null) {
      this.logLevel = opts.level;
    } else {
      this.logLevel = utils.LogLevel.info;
      for (const debugStr of debugStrs) {
        if (debugStr) {
          if (truthy(debugStr)) {
            this.logLevel = utils.LogLevel.debug;
            break;
          }
          if (opts?.name) {
            if (debugStr?.toString()?.includes(opts.name)) {
              this.logLevel = utils.LogLevel.debug;
              break;
            }
          }
        }
      }
    }
  }
  log(...messageArgs) {
    if (this.logLevel > utils.LogLevel.info) {
      return;
    }
    const finalMessage = this.prepareFinalMessage("info", messageArgs);
    this.console.log(finalMessage);
  }
  warn(...messageArgs) {
    if (this.logLevel > utils.LogLevel.warn) {
      return;
    }
    const finalMessage = this.prepareFinalMessage("warn", messageArgs);
    this.console.warn(finalMessage);
  }
  info(...messageArgs) {
    if (this.logLevel > utils.LogLevel.info) {
      return;
    }
    const finalMessage = this.prepareFinalMessage("info", messageArgs);
    this.console.info(finalMessage);
  }
  error(...messageArgs) {
    if (this.logLevel > utils.LogLevel.error) {
      return;
    }
    const finalMessage = this.prepareFinalMessage("error", messageArgs);
    this.console.error(finalMessage);
  }
  debug(...messageArgs) {
    if (this.logLevel > utils.LogLevel.debug) {
      return;
    }
    const finalMessage = this.prepareFinalMessage("debug", messageArgs);
    this.console.debug(finalMessage);
  }
  child(nameOrMeta) {
    let newName;
    let newMeta;
    if (typeof nameOrMeta === "string") {
      newName = this.name ? `${this.name}, ${nameOrMeta}` : nameOrMeta;
      newMeta = this.meta;
    } else if (typeof nameOrMeta === "object") {
      newName = this.name;
      newMeta = { ...this.meta, ...nameOrMeta };
    } else {
      throw new Error("Invalid argument type");
    }
    return new JSONLogger({
      name: newName,
      meta: newMeta,
      level: this.logLevel,
      console: this.console
    });
  }
  addPrefix(prefix) {
    if (typeof prefix === "string") {
      this.name = this.name ? `${this.name}, ${prefix}` : prefix;
    } else if (typeof prefix === "object") {
      this.meta = { ...this.meta, ...prefix };
    }
    return this;
  }
  prepareFinalMessage(level, messageArgs) {
    const flattenedMessageArgs = messageArgs.flat(Infinity).flatMap((messageArg) => {
      if (typeof messageArg === "function") {
        messageArg = messageArg();
      }
      if (messageArg?.toJSON) {
        messageArg = messageArg.toJSON();
      }
      if (messageArg instanceof AggregateError) {
        return messageArg.errors;
      }
      return messageArg;
    });
    const finalMessage = {
      ...this.meta,
      level,
      time: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (this.name) {
      finalMessage["name"] = this.name;
    }
    const extras = [];
    for (let messageArg of flattenedMessageArgs) {
      if (messageArg == null) {
        continue;
      }
      const typeofMessageArg = typeof messageArg;
      if (typeofMessageArg === "string" || typeofMessageArg === "number" || typeofMessageArg === "boolean") {
        finalMessage["msg"] = finalMessage["msg"] ? finalMessage["msg"] + ", " + messageArg : messageArg;
      } else if (typeofMessageArg === "object") {
        if (messageArg instanceof Error) {
          finalMessage["msg"] = finalMessage["msg"] ? finalMessage["msg"] + ", " + messageArg.message : messageArg.message;
          finalMessage["stack"] = messageArg.stack;
        } else if (Object.prototype.toString.call(messageArg).startsWith("[object")) {
          Object.assign(finalMessage, messageArg);
        } else {
          extras.push(messageArg);
        }
      }
    }
    if (extras.length) {
      if (extras.length === 1) {
        finalMessage["extras"] = crossInspect.inspect(extras[0]);
      } else {
        finalMessage["extras"] = extras.map((extra) => crossInspect.inspect(extra));
      }
    }
    return JSON.stringify(finalMessage);
  }
}

exports.JSONLogger = JSONLogger;
