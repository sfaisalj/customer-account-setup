import { version } from '../version.js';
import { http } from './http-client.js';
export function createAgent(pluginOptions, { data, body, headers = () => ({}), }) {
    const options = Object.assign({ timeout: 30000, debug: false, enabled: true, minTimeout: 200, maxRetries: 3, sendInterval: 10000, maxSize: 25, logger: console, name: 'hive-client' }, pluginOptions);
    const enabled = options.enabled !== false;
    let timeoutID = null;
    function schedule() {
        if (timeoutID) {
            clearTimeout(timeoutID);
        }
        timeoutID = setTimeout(send, options.sendInterval);
    }
    function debugLog(msg) {
        if (options.debug) {
            options.logger.info(msg);
        }
    }
    function errorLog(msg) {
        options.logger.error(msg);
    }
    let scheduled = false;
    let inProgressCaptures = [];
    function capture(event) {
        if (event instanceof Promise) {
            const promise = captureAsync(event);
            inProgressCaptures.push(promise);
            void promise.finally(() => {
                inProgressCaptures = inProgressCaptures.filter(p => p !== promise);
            });
        }
        else {
            captureSync(event);
        }
    }
    async function captureAsync(event) {
        captureSync(await event);
    }
    function captureSync(event) {
        // Calling capture starts the schedule
        if (!scheduled) {
            scheduled = true;
            schedule();
        }
        data.set(event);
        if (data.size() >= options.maxSize) {
            debugLog('Sending immediately');
            setImmediate(() => send({ throwOnError: false, skipSchedule: true }));
        }
    }
    function sendImmediately(event) {
        data.set(event);
        debugLog('Sending immediately');
        return send({ throwOnError: true, skipSchedule: true });
    }
    async function send(sendOptions) {
        if (!data.size() || !enabled) {
            if (!(sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions.skipSchedule)) {
                schedule();
            }
            return null;
        }
        const buffer = await body();
        const dataToSend = data.size();
        data.clear();
        debugLog(`Sending report (queue ${dataToSend})`);
        const response = await http
            .post(options.endpoint, buffer, {
            headers: Object.assign({ accept: 'application/json', 'content-type': 'application/json', Authorization: `Bearer ${options.token}`, 'User-Agent': `${options.name}/${version}` }, headers()),
            timeout: options.timeout,
            retry: {
                retries: options.maxRetries,
                factor: 2,
            },
            logger: options.logger,
            fetchImplementation: pluginOptions.fetch,
        })
            .then(res => {
            debugLog(`Report sent!`);
            return res;
        })
            .catch(error => {
            errorLog(`Failed to send report.`);
            if (sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions.throwOnError) {
                throw error;
            }
            return null;
        })
            .finally(() => {
            if (!(sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions.skipSchedule)) {
                schedule();
            }
        });
        return response;
    }
    async function dispose() {
        debugLog('Disposing');
        if (timeoutID) {
            clearTimeout(timeoutID);
        }
        if (inProgressCaptures.length) {
            await Promise.all(inProgressCaptures);
        }
        await send({
            skipSchedule: true,
            throwOnError: false,
        });
    }
    return {
        capture,
        sendImmediately,
        dispose,
    };
}
