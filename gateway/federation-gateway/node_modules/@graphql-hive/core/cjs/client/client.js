"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoDisposeSymbol = exports.hiveClientSymbol = void 0;
exports.createHive = createHive;
const version_js_1 = require("../version.js");
const http_client_js_1 = require("./http-client.js");
const persisted_documents_js_1 = require("./persisted-documents.js");
const reporting_js_1 = require("./reporting.js");
const usage_js_1 = require("./usage.js");
const utils_js_1 = require("./utils.js");
function createHive(options) {
    var _a, _b, _c, _d, _e;
    const logger = (0, utils_js_1.createHiveLogger)((_b = (_a = options === null || options === void 0 ? void 0 : options.agent) === null || _a === void 0 ? void 0 : _a.logger) !== null && _b !== void 0 ? _b : console, '[hive]');
    let enabled = (_c = options.enabled) !== null && _c !== void 0 ? _c : true;
    if (enabled === false) {
        (0, utils_js_1.logIf)(options.debug === true &&
            // hive client can be used only for persisted documents, without the cdn or usage reporting.
            // hence, we dont want a misleading log message below saying that the plugin is disabled
            !options.experimental__persistedDocuments, 'Plugin is not enabled.', logger.info);
    }
    if (!options.token && enabled) {
        enabled = false;
        logger.info('Missing token, disabling.');
    }
    const mergedOptions = Object.assign(Object.assign({}, options), { enabled });
    const usage = (0, usage_js_1.createUsage)(mergedOptions);
    const schemaReporter = (0, reporting_js_1.createReporting)(mergedOptions);
    function reportSchema({ schema }) {
        schemaReporter.report({ schema });
    }
    function collectUsage() {
        return usage.collect();
    }
    function collectRequest(...args) {
        return usage.collectRequest(...args);
    }
    async function dispose() {
        await Promise.all([schemaReporter.dispose(), usage.dispose()]);
    }
    const isOrganizationAccessToken = ((_d = options.token) === null || _d === void 0 ? void 0 : _d.startsWith('hvo1/')) === true;
    // enabledOnly when `printTokenInfo` is `true` or `debug` is true and `printTokenInfo` is not `false`
    const printTokenInfo = enabled &&
        /** Access tokens using the `hvo1/` prefix cannot print any token information. */
        isOrganizationAccessToken === false
        ? options.printTokenInfo === true || (!!options.debug && options.printTokenInfo !== false)
        : false;
    const infoLogger = (0, utils_js_1.createHiveLogger)(logger, '[info]');
    const info = printTokenInfo
        ? async () => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            try {
                let endpoint = 'https://app.graphql-hive.com/graphql';
                // Look for the reporting.endpoint for the legacy reason.
                if (options.reporting && options.reporting.endpoint) {
                    endpoint = options.reporting.endpoint;
                }
                if ((_a = options.selfHosting) === null || _a === void 0 ? void 0 : _a.graphqlEndpoint) {
                    endpoint = options.selfHosting.graphqlEndpoint;
                }
                const query = /* GraphQL */ `
            query myTokenInfo {
              tokenInfo {
                __typename
                ... on TokenInfo {
                  token {
                    name
                  }
                  organization {
                    slug
                  }
                  project {
                    type
                    slug
                  }
                  target {
                    slug
                  }
                  canReportSchema: hasTargetScope(scope: REGISTRY_WRITE)
                  canCollectUsage: hasTargetScope(scope: REGISTRY_WRITE)
                  canReadOperations: hasProjectScope(scope: OPERATIONS_STORE_READ)
                }
                ... on TokenNotFoundError {
                  message
                }
              }
            }
          `;
                infoLogger.info('Fetching token details...');
                const response = await http_client_js_1.http.post(endpoint, JSON.stringify({
                    query,
                    operationName: 'myTokenInfo',
                }), {
                    headers: {
                        'content-type': 'application/json',
                        Authorization: `Bearer ${options.token}`,
                        'user-agent': `hive-client/${version_js_1.version}`,
                        'graphql-client-name': 'Hive Client',
                        'graphql-client-version': version_js_1.version,
                    },
                    timeout: 30000,
                    fetchImplementation: (_b = options === null || options === void 0 ? void 0 : options.agent) === null || _b === void 0 ? void 0 : _b.fetch,
                    logger: infoLogger,
                });
                if (response.ok) {
                    const result = await response.json();
                    if (((_c = result.data) === null || _c === void 0 ? void 0 : _c.tokenInfo.__typename) === 'TokenInfo') {
                        const { tokenInfo } = result.data;
                        const { organization, project, target, canReportSchema, canCollectUsage, canReadOperations, } = tokenInfo;
                        const print = createPrinter([
                            tokenInfo.token.name,
                            organization.name,
                            project.name,
                            target.name,
                        ]);
                        const appUrl = (_f = (_e = (_d = options.selfHosting) === null || _d === void 0 ? void 0 : _d.applicationUrl) === null || _e === void 0 ? void 0 : _e.replace(/\/$/, '')) !== null && _f !== void 0 ? _f : 'https://app.graphql-hive.com';
                        const organizationUrl = `${appUrl}/${organization.slug}`;
                        const projectUrl = `${organizationUrl}/${project.slug}`;
                        const targetUrl = `${projectUrl}/${target.slug}`;
                        infoLogger.info([
                            'Token details',
                            '',
                            `Token name:            ${print(tokenInfo.token.name)}`,
                            `Organization:          ${print(organization.name, organizationUrl)}`,
                            `Project:               ${print(project.name, projectUrl)}`,
                            `Target:                ${print(target.name, targetUrl)}`,
                            '',
                            `Can report schema?     ${print(canReportSchema ? 'Yes' : 'No')}`,
                            `Can collect usage?     ${print(canCollectUsage ? 'Yes' : 'No')}`,
                            `Can read operations?   ${print(canReadOperations ? 'Yes' : 'No')}`,
                            '',
                        ].join('\n'));
                    }
                    else if ((_g = result.data) === null || _g === void 0 ? void 0 : _g.tokenInfo.message) {
                        infoLogger.error(`Token not found. Reason: ${(_h = result.data) === null || _h === void 0 ? void 0 : _h.tokenInfo.message}`);
                        infoLogger.info(`How to create a token? https://docs.graphql-hive.com/features/tokens`);
                    }
                    else {
                        infoLogger.error(`${result.errors[0].message}`);
                        infoLogger.info(`How to create a token? https://docs.graphql-hive.com/features/tokens`);
                    }
                }
                else {
                    infoLogger.error(`Error ${response.status}: ${response.statusText}`);
                }
            }
            catch (error) {
                infoLogger.error(`Error ${(_j = error === null || error === void 0 ? void 0 : error.message) !== null && _j !== void 0 ? _j : error}`);
            }
        }
        : () => { };
    function createInstrumentedExecute(executeImpl) {
        return function hiveInstrumentedExecute(args) {
            const collect = usage.collect();
            const result = executeImpl(args);
            if ('then' in result) {
                void result.then(result => collect(args, result));
            }
            else {
                void collect(args, result);
            }
            return result;
        };
    }
    function createInstrumentedSubscribe(subscribeImpl) {
        return function hiveInstrumentedSubscribe(args) {
            usage.collectSubscription({ args });
            return subscribeImpl(args);
        };
    }
    return {
        [exports.hiveClientSymbol]: true,
        [exports.autoDisposeSymbol]: (_e = options.autoDispose) !== null && _e !== void 0 ? _e : true,
        info,
        reportSchema,
        collectUsage,
        collectRequest,
        dispose,
        collectSubscriptionUsage: usage.collectSubscription,
        createInstrumentedSubscribe,
        createInstrumentedExecute,
        experimental__persistedDocuments: options.experimental__persistedDocuments
            ? (0, persisted_documents_js_1.createPersistedDocuments)(Object.assign(Object.assign({}, options.experimental__persistedDocuments), { logger }))
            : null,
    };
}
exports.hiveClientSymbol = Symbol('hive-client');
exports.autoDisposeSymbol = Symbol('hive-auto-dispose');
function createPrinter(values) {
    const maxLen = Math.max(...values.map(v => v.length)) + 4;
    return (base, extra) => {
        return base.padEnd(maxLen, ' ') + (extra || '');
    };
}
