export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
export type Incremental<T> = T | {
    [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    Date: {
        input: any;
        output: any;
    };
    /**
     * A date-time string at UTC, such as `2007-12-03T10:15:30Z`, is compliant with the date-time format outlined
     * in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
     *
     * This scalar is a description of an exact instant on the timeline such as the instant that a user account was created.
     *
     * This scalar ignores leap seconds (thereby assuming that a minute constitutes 59 seconds). In this respect, it diverges from the RFC 3339 profile.
     *
     * Where an RFC 3339 compliant date-time string has a time-zone other than UTC, it is shifted to UTC. For example, the date-time string `2016-01-01T14:10:20+01:00` is shifted to `2016-01-01T13:10:20Z`.
     */
    DateTime: {
        input: any;
        output: any;
    };
    JSON: {
        input: any;
        output: any;
    };
    JSONSchemaObject: {
        input: any;
        output: any;
    };
    SafeInt: {
        input: any;
        output: any;
    };
};
export type ActivateAppDeploymentInput = {
    appName: Scalars['String']['input'];
    appVersion: Scalars['String']['input'];
    target?: InputMaybe<TargetReferenceInput>;
};
export type AddAlertChannelInput = {
    name: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    slack?: InputMaybe<SlackChannelInput>;
    type: AlertChannelType;
    webhook?: InputMaybe<WebhookChannelInput>;
};
export type AddAlertInput = {
    channelId: Scalars['ID']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
    type: AlertType;
};
export type AddDocumentsToAppDeploymentInput = {
    /** Name of the app. */
    appName: Scalars['String']['input'];
    /** The version of the app */
    appVersion: Scalars['String']['input'];
    /** A list of operations to add to the app deployment. (max 100 per single batch) */
    documents: Array<DocumentInput>;
    target?: InputMaybe<TargetReferenceInput>;
};
export type AddGitHubIntegrationInput = {
    installationId: Scalars['ID']['input'];
    organizationSlug: Scalars['String']['input'];
};
export type AddSlackIntegrationInput = {
    organizationSlug: Scalars['String']['input'];
    token: Scalars['String']['input'];
};
export declare enum AlertChannelType {
    MsteamsWebhook = "MSTEAMS_WEBHOOK",
    Slack = "SLACK",
    Webhook = "WEBHOOK"
}
export declare enum AlertType {
    SchemaChangeNotifications = "SCHEMA_CHANGE_NOTIFICATIONS"
}
export type AnswerOrganizationTransferRequestInput = {
    accept: Scalars['Boolean']['input'];
    code: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
};
export type AppDeploymentOperation = {
    /** GraphQL operation body. */
    body: Scalars['String']['input'];
    /** GraphQL operation hash. */
    hash: Scalars['String']['input'];
};
export type AppDeploymentResourceAssignmentInput = {
    appDeployment: Scalars['String']['input'];
};
export declare enum AppDeploymentStatus {
    Active = "active",
    Pending = "pending",
    Retired = "retired"
}
export type ApproveFailedSchemaCheckInput = {
    /**
     * Optional comment visible in the schema check.
     * Give a reason why the schema check was approved.
     */
    comment?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    schemaCheckId: Scalars['ID']['input'];
    targetSlug: Scalars['String']['input'];
};
export type AssignMemberRoleInput = {
    member: MemberReferenceInput;
    memberRole: MemberRoleReferenceInput;
    organization: OrganizationReferenceInput;
    resources: ResourceAssignmentInput;
};
export type AuditLogFilter = {
    endDate: Scalars['DateTime']['input'];
    startDate: Scalars['DateTime']['input'];
};
export declare enum AuthProviderType {
    Github = "GITHUB",
    Google = "GOOGLE",
    /** OpenID Connect */
    Oidc = "OIDC",
    /** Username-Password-Authentication */
    UsernamePassword = "USERNAME_PASSWORD"
}
export declare enum BillingInvoiceStatus {
    Draft = "DRAFT",
    Open = "OPEN",
    Paid = "PAID",
    Uncollectible = "UNCOLLECTIBLE",
    Void = "VOID"
}
export declare enum BillingPlanType {
    Enterprise = "ENTERPRISE",
    Hobby = "HOBBY",
    Pro = "PRO"
}
export declare enum BreakingChangeFormulaType {
    Percentage = "PERCENTAGE",
    RequestCount = "REQUEST_COUNT"
}
export type ClientStatsByTargetsInput = {
    organizationSlug: Scalars['String']['input'];
    period: DateRangeInput;
    projectSlug: Scalars['String']['input'];
    targetIds: Array<Scalars['ID']['input']>;
};
/** Fields not provided (omitted) will retain the previous value. */
export type ConditionalBreakingChangeConfigurationInput = {
    /** Whether a percentage or absolute value should be used for the conditional breaking changes treshold. */
    breakingChangeFormula?: InputMaybe<BreakingChangeFormulaType>;
    /** List of client names that are excluded from the breaking change detection. */
    excludedClients?: InputMaybe<Array<Scalars['String']['input']>>;
    /** Update whethe the conditional breaking change detection is enabled or disabled. */
    isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
    /** The percentage value if `UpdateTargetValidationSettingsInput.breakingChangeFormula` is set to `BreakingChangeFormulaType.PERCENTAGE`. */
    percentage?: InputMaybe<Scalars['Float']['input']>;
    /**
     * The period in days. Operations of the last x days will be used for the conditional breaking change detection.
     * The maximum value depends on the organizations data retention limits.
     */
    period?: InputMaybe<Scalars['Int']['input']>;
    /** The request count value if `UpdateTargetValidationSettingsInput.breakingChangeFormula` is set to `BreakingChangeFormulaType.REQUEST_COUNT`. */
    requestCount?: InputMaybe<Scalars['Int']['input']>;
    /** List of target ids within the same project, whose operations are used for the breaking change detection. */
    targetIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};
export type ContractReferenceInput = {
    byId: Scalars['ID']['input'];
};
export type CreateAppDeploymentInput = {
    appName: Scalars['String']['input'];
    appVersion: Scalars['String']['input'];
    target?: InputMaybe<TargetReferenceInput>;
};
export type CreateCdnAccessTokenInput = {
    /** Alias describing the purpose of the access token. */
    alias: Scalars['String']['input'];
    /** The target for which the access token should be created for. */
    target: TargetReferenceInput;
};
export type CreateContractInput = {
    contractName: Scalars['String']['input'];
    excludeTags?: InputMaybe<Array<Scalars['String']['input']>>;
    includeTags?: InputMaybe<Array<Scalars['String']['input']>>;
    removeUnreachableTypesFromPublicApiSchema: Scalars['Boolean']['input'];
    target: TargetReferenceInput;
};
export type CreateDocumentCollectionInput = {
    description?: InputMaybe<Scalars['String']['input']>;
    name: Scalars['String']['input'];
};
export type CreateDocumentCollectionOperationInput = {
    collectionId: Scalars['ID']['input'];
    headers?: InputMaybe<Scalars['String']['input']>;
    name: Scalars['String']['input'];
    query: Scalars['String']['input'];
    variables?: InputMaybe<Scalars['String']['input']>;
};
export type CreateMemberRoleInput = {
    /** A description describing the purpose of the member role. */
    description: Scalars['String']['input'];
    /** The name of the member role (must be unique). */
    name: Scalars['String']['input'];
    /** The organization in which the member role should be created. */
    organization: OrganizationReferenceInput;
    /** A list of available permissions can be retrieved via the `Organization.availableMemberPermissionGroups` field. */
    selectedPermissions: Array<Scalars['String']['input']>;
};
export type CreateOidcIntegrationInput = {
    authorizationEndpoint: Scalars['String']['input'];
    clientId: Scalars['ID']['input'];
    clientSecret: Scalars['String']['input'];
    organizationId: Scalars['ID']['input'];
    tokenEndpoint: Scalars['String']['input'];
    userinfoEndpoint: Scalars['String']['input'];
};
export type CreateOrganizationAccessTokenInput = {
    /** Additional description containing information about the purpose of the access token. */
    description?: InputMaybe<Scalars['String']['input']>;
    /** Organization in which the access token should be created. */
    organization: OrganizationReferenceInput;
    /**
     * List of permissions that are assigned to the access token.
     * A list of available permissions can be retrieved via the `Organization.availableOrganizationAccessTokenPermissionGroups` field.
     */
    permissions: Array<Scalars['String']['input']>;
    /**
     * Resources on which the permissions should be granted (project, target, service, and app deployments).
     * Permissions are inherited by sub-resources.
     */
    resources: ResourceAssignmentInput;
    /** Title of the access token. */
    title: Scalars['String']['input'];
};
export type CreateOrganizationInput = {
    slug: Scalars['String']['input'];
};
export type CreateProjectInput = {
    organization: OrganizationReferenceInput;
    slug: Scalars['String']['input'];
    type: ProjectType;
};
export type CreateTargetInput = {
    /** Reference to the project in which the target should be created in. */
    project: ProjectReferenceInput;
    /** Slug of the target, must be unique per project. */
    slug: Scalars['String']['input'];
};
export type CreateTokenInput = {
    name: Scalars['String']['input'];
    organizationScopes: Array<OrganizationAccessScope>;
    organizationSlug: Scalars['String']['input'];
    projectScopes: Array<ProjectAccessScope>;
    projectSlug: Scalars['String']['input'];
    targetScopes: Array<TargetAccessScope>;
    targetSlug: Scalars['String']['input'];
};
export declare enum CriticalityLevel {
    /** @deprecated Use 'SeverityLevelType' instead. This field will be removed once it is no longer in use by a client. */
    Breaking = "Breaking",
    /** @deprecated Use 'SeverityLevelType' instead. This field will be removed once it is no longer in use by a client. */
    Dangerous = "Dangerous",
    /** @deprecated Use 'SeverityLevelType' instead. This field will be removed once it is no longer in use by a client. */
    Safe = "Safe"
}
/** Describes a date range interval. */
export type DateRangeInput = {
    from: Scalars['DateTime']['input'];
    to: Scalars['DateTime']['input'];
};
export type DeleteAlertChannelsInput = {
    channelIds: Array<Scalars['ID']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type DeleteAlertsInput = {
    alertIds: Array<Scalars['ID']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type DeleteCdnAccessTokenInput = {
    cdnAccessTokenId: Scalars['ID']['input'];
    target: TargetReferenceInput;
};
export type DeleteMemberRoleInput = {
    memberRole: MemberRoleReferenceInput;
};
export type DeleteOidcIntegrationInput = {
    oidcIntegrationId: Scalars['ID']['input'];
};
export type DeleteOrganizationAccessTokenInput = {
    /** The access token that should be deleted. */
    organizationAccessToken: OrganizationAccessTokenReference;
};
export type DeleteOrganizationInvitationInput = {
    email: Scalars['String']['input'];
    organization: OrganizationReferenceInput;
};
export type DeleteProjectInput = {
    project: ProjectReferenceInput;
};
export type DeleteTargetInput = {
    /** Reference to the target that should be deleted. */
    target: TargetReferenceInput;
};
export type DeleteTokensInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
    tokenIds: Array<Scalars['ID']['input']>;
};
export type DeprecatedSchemaExplorerUsageInput = {
    period: DateRangeInput;
};
export type DisableContractInput = {
    contract: ContractReferenceInput;
};
export type DisableExternalSchemaCompositionInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type DocumentInput = {
    /** GraphQL operation body. */
    body: Scalars['String']['input'];
    /** GraphQL operation hash. */
    hash: Scalars['String']['input'];
};
export type DowngradeToHobbyInput = {
    organization: OrganizationSelectorInput;
};
export type EnableExternalSchemaCompositionInput = {
    endpoint: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    secret: Scalars['String']['input'];
};
export type Experimental__UpdateTargetSchemaCompositionInput = {
    nativeComposition: Scalars['Boolean']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type ExportOrganizationAuditLogInput = {
    filter: AuditLogFilter;
    selector: OrganizationSelectorInput;
};
export type FieldListStatsInput = {
    fields: Array<FieldTypePairInput>;
    operationHash?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    period: DateRangeInput;
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type FieldStatsInput = {
    argument?: InputMaybe<Scalars['String']['input']>;
    field: Scalars['String']['input'];
    operationHash?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    period: DateRangeInput;
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
    type: Scalars['String']['input'];
};
export type FieldTypePairInput = {
    argument?: InputMaybe<Scalars['String']['input']>;
    field: Scalars['String']['input'];
    type: Scalars['String']['input'];
};
export type GitHubSchemaCheckInput = {
    commit: Scalars['String']['input'];
    /** The pull request number of the schema check. */
    pullRequestNumber?: InputMaybe<Scalars['String']['input']>;
    /** The repository name of the schema check. */
    repository?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GraphQlOperationType {
    Mutation = "MUTATION",
    Query = "QUERY",
    Subscription = "SUBSCRIPTION"
}
export type InviteToOrganizationByEmailInput = {
    email: Scalars['String']['input'];
    memberRoleId?: InputMaybe<Scalars['ID']['input']>;
    organization: OrganizationReferenceInput;
};
export type MemberReferenceInput = {
    byId: Scalars['ID']['input'];
};
export type MemberRoleReferenceInput = {
    byId: Scalars['ID']['input'];
};
export declare enum NativeFederationCompatibilityStatus {
    Compatible = "COMPATIBLE",
    Incompatible = "INCOMPATIBLE",
    NotApplicable = "NOT_APPLICABLE",
    Unknown = "UNKNOWN"
}
export type OidcIntegrationLogSubscriptionInput = {
    oidcIntegrationId: Scalars['ID']['input'];
};
export type OperationStatsFilterInput = {
    /** Filter by only showing operations performed by specific clients. */
    clientNames?: InputMaybe<Array<Scalars['String']['input']>>;
    /** Filter by only showing operations with a specific id. */
    operationIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};
export declare enum OrganizationAccessScope {
    Delete = "DELETE",
    Integrations = "INTEGRATIONS",
    Members = "MEMBERS",
    Read = "READ",
    Settings = "SETTINGS"
}
export type OrganizationAccessTokenReference = {
    byId: Scalars['ID']['input'];
};
export type OrganizationMemberInput = {
    organizationSlug: Scalars['String']['input'];
    userId: Scalars['ID']['input'];
};
export type OrganizationReferenceInput = {
    byId: Scalars['ID']['input'];
    bySelector?: never;
} | {
    byId?: never;
    bySelector: OrganizationSelectorInput;
};
export type OrganizationSelectorInput = {
    organizationSlug: Scalars['String']['input'];
};
export type OrganizationTransferRequestSelector = {
    code: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
};
export declare enum PermissionLevelType {
    AppDeployment = "APP_DEPLOYMENT",
    Organization = "ORGANIZATION",
    Project = "PROJECT",
    Service = "SERVICE",
    Target = "TARGET"
}
export declare enum ProjectAccessScope {
    Alerts = "ALERTS",
    Delete = "DELETE",
    OperationsStoreRead = "OPERATIONS_STORE_READ",
    OperationsStoreWrite = "OPERATIONS_STORE_WRITE",
    Read = "READ",
    Settings = "SETTINGS"
}
export type ProjectReferenceInput = {
    byId: Scalars['ID']['input'];
    bySelector?: never;
} | {
    byId?: never;
    bySelector: ProjectSelectorInput;
};
export type ProjectResourceAssignmentInput = {
    projectId: Scalars['ID']['input'];
    targets: ProjectTargetsResourceAssignmentInput;
};
export type ProjectSelectorInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type ProjectTargetsResourceAssignmentInput = {
    /** Whether the permissions should apply for all targets within the project or only selected ones. */
    mode: ResourceAssignmentModeType;
    /** Specific targets within the projects for which the permissions should be applied. */
    targets?: InputMaybe<Array<TargetResourceAssignmentInput>>;
};
export declare enum ProjectType {
    Federation = "FEDERATION",
    Single = "SINGLE",
    Stitching = "STITCHING"
}
export type RateLimitInput = {
    operations: Scalars['SafeInt']['input'];
};
export type RequestOrganizationTransferInput = {
    organizationSlug: Scalars['String']['input'];
    userId: Scalars['ID']['input'];
};
export type ResourceAssignmentInput = {
    /** Whether the permissions should apply for all projects within the organization or only selected ones. */
    mode: ResourceAssignmentModeType;
    /** Specific projects within the organization for which the permissions should be applied. */
    projects?: InputMaybe<Array<ProjectResourceAssignmentInput>>;
};
export declare enum ResourceAssignmentModeType {
    /** Apply to all subresouces of the resource. */
    All = "ALL",
    /** Apply to specific subresouces of the resource. */
    Granular = "GRANULAR"
}
export type RetireAppDeploymentInput = {
    appName: Scalars['String']['input'];
    appVersion: Scalars['String']['input'];
    targetId: Scalars['ID']['input'];
};
export declare enum RuleInstanceSeverityLevel {
    Error = "ERROR",
    Off = "OFF",
    Warning = "WARNING"
}
export type SchemaCheckInput = {
    /**
     * Optional context ID to group schema checks together.
     * Manually approved breaking changes will be memorized for schema checks with the same context id.
     */
    contextId?: InputMaybe<Scalars['String']['input']>;
    github?: InputMaybe<GitHubSchemaCheckInput>;
    meta?: InputMaybe<SchemaCheckMetaInput>;
    sdl: Scalars['String']['input'];
    service?: InputMaybe<Scalars['ID']['input']>;
    target?: InputMaybe<TargetReferenceInput>;
    /** Optional url if wanting to show subgraph url changes inside checks. */
    url?: InputMaybe<Scalars['String']['input']>;
};
export type SchemaCheckMetaInput = {
    author: Scalars['String']['input'];
    commit: Scalars['String']['input'];
};
export type SchemaChecksFilter = {
    changed?: InputMaybe<Scalars['Boolean']['input']>;
    failed?: InputMaybe<Scalars['Boolean']['input']>;
};
export type SchemaCompareInput = {
    after: Scalars['ID']['input'];
    before: Scalars['ID']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type SchemaComposeInput = {
    services: Array<SchemaComposeServiceInput>;
    target?: InputMaybe<TargetReferenceInput>;
    /**
     * Whether to use the latest composable version or just latest schema version for the composition.
     * Latest schema version may or may not be composable.
     * It's true by default, which means the latest composable schema version is used.
     */
    useLatestComposableVersion?: InputMaybe<Scalars['Boolean']['input']>;
};
export type SchemaComposeServiceInput = {
    name: Scalars['String']['input'];
    sdl: Scalars['String']['input'];
    url?: InputMaybe<Scalars['String']['input']>;
};
export type SchemaDeleteInput = {
    dryRun?: InputMaybe<Scalars['Boolean']['input']>;
    serviceName: Scalars['ID']['input'];
    target?: InputMaybe<TargetReferenceInput>;
};
export type SchemaExplorerUsageInput = {
    period: DateRangeInput;
};
export type SchemaPolicyInput = {
    rules: Array<SchemaPolicyRuleInstanceInput>;
};
export declare enum SchemaPolicyLevel {
    Organization = "ORGANIZATION",
    Project = "PROJECT"
}
export type SchemaPolicyRuleInstanceInput = {
    configuration?: InputMaybe<Scalars['JSON']['input']>;
    ruleId: Scalars['String']['input'];
    severity: RuleInstanceSeverityLevel;
};
export type SchemaPublishGitHubInput = {
    /** The commit sha. */
    commit: Scalars['String']['input'];
    /** The repository name. */
    repository: Scalars['String']['input'];
};
export type SchemaPublishInput = {
    author: Scalars['String']['input'];
    commit: Scalars['String']['input'];
    /**
     * Accept breaking changes and mark schema as valid (if composable)
     * @deprecated Enabled by default for newly created projects
     */
    experimental_acceptBreakingChanges?: InputMaybe<Scalars['Boolean']['input']>;
    /** @deprecated Enabled by default for newly created projects */
    force?: InputMaybe<Scalars['Boolean']['input']>;
    /** Link GitHub version to a GitHub commit on a repository. */
    gitHub?: InputMaybe<SchemaPublishGitHubInput>;
    /**
     * Talk to GitHub Application and create a check-run
     * @deprecated Use SchemaPublishInput.gitHub instead.
     */
    github?: InputMaybe<Scalars['Boolean']['input']>;
    metadata?: InputMaybe<Scalars['String']['input']>;
    sdl: Scalars['String']['input'];
    service?: InputMaybe<Scalars['ID']['input']>;
    /** Whether the CLI supports retrying the schema publish, in case acquiring the schema publish lock fails due to a busy queue. */
    supportsRetry?: InputMaybe<Scalars['Boolean']['input']>;
    target?: InputMaybe<TargetReferenceInput>;
    url?: InputMaybe<Scalars['String']['input']>;
};
export type SchemaVersionUpdateInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
    valid: Scalars['Boolean']['input'];
    versionId: Scalars['ID']['input'];
};
export type ServiceResourceAssignmentInput = {
    serviceName: Scalars['String']['input'];
};
/** Describes the impact of a schema change. */
export declare enum SeverityLevelType {
    /** The change will definetly break GraphQL client users. */
    Breaking = "BREAKING",
    /**
     * The change might break existing clients that do not follow
     * best-practises such as future-proof enums or future-proof interface/union type usages.
     */
    Dangerous = "DANGEROUS",
    /** The change is safe and does not break existing clients. */
    Safe = "SAFE"
}
export type SlackChannelInput = {
    channel: Scalars['String']['input'];
};
export type SupportTicketCreateInput = {
    description: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
    priority: SupportTicketPriority;
    subject: Scalars['String']['input'];
};
export declare enum SupportTicketPriority {
    High = "HIGH",
    Normal = "NORMAL",
    Urgent = "URGENT"
}
export type SupportTicketReplyInput = {
    body: Scalars['String']['input'];
    organizationSlug: Scalars['String']['input'];
    ticketId: Scalars['String']['input'];
};
export declare enum SupportTicketStatus {
    Open = "OPEN",
    Solved = "SOLVED"
}
export declare enum TargetAccessScope {
    Delete = "DELETE",
    Read = "READ",
    RegistryRead = "REGISTRY_READ",
    RegistryWrite = "REGISTRY_WRITE",
    Settings = "SETTINGS",
    TokensRead = "TOKENS_READ",
    TokensWrite = "TOKENS_WRITE"
}
export type TargetAppDeploymentsResourceAssignmentInput = {
    /** Specific app deployments within the target for which the permissions should be applied. */
    appDeployments?: InputMaybe<Array<AppDeploymentResourceAssignmentInput>>;
    /** Whether the permissions should apply for all app deployments within the target. */
    mode: ResourceAssignmentModeType;
};
/** Reference to a target. */
export type TargetReferenceInput = 
/** Reference to a target using it's ID (see "Target.id" field). */
{
    byId: Scalars['ID']['input'];
    bySelector?: never;
} | /** Reference to a target using it's slug parts (see "Organization.slug", "Project.slug", "Target.slug"). */ {
    byId?: never;
    bySelector: TargetSelectorInput;
};
export type TargetResourceAssignmentInput = {
    appDeployments: TargetAppDeploymentsResourceAssignmentInput;
    services: TargetServicesResourceAssignmentInput;
    targetId: Scalars['ID']['input'];
};
export type TargetSelectorInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type TargetServicesResourceAssignmentInput = {
    /** Whether the permissions should apply for all services within the target or only selected ones. */
    mode: ResourceAssignmentModeType;
    /** Specific services within the target for which the permissions should be applied. */
    services?: InputMaybe<Array<ServiceResourceAssignmentInput>>;
};
export type TestExternalSchemaCompositionInput = {
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type UnusedSchemaExplorerUsageInput = {
    period: DateRangeInput;
};
export type UpdateBaseSchemaInput = {
    newBase?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
    targetSlug: Scalars['String']['input'];
};
export type UpdateDocumentCollectionInput = {
    collectionId: Scalars['ID']['input'];
    description?: InputMaybe<Scalars['String']['input']>;
    name: Scalars['String']['input'];
};
export type UpdateDocumentCollectionOperationInput = {
    collectionId: Scalars['ID']['input'];
    headers?: InputMaybe<Scalars['String']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    operationId: Scalars['ID']['input'];
    query?: InputMaybe<Scalars['String']['input']>;
    variables?: InputMaybe<Scalars['String']['input']>;
};
export type UpdateMeInput = {
    displayName: Scalars['String']['input'];
    fullName: Scalars['String']['input'];
};
export type UpdateMemberRoleInput = {
    description: Scalars['String']['input'];
    /** The member role that should be udpated. */
    memberRole: MemberRoleReferenceInput;
    name: Scalars['String']['input'];
    selectedPermissions: Array<Scalars['String']['input']>;
};
export type UpdateNativeFederationInput = {
    enabled: Scalars['Boolean']['input'];
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type UpdateOidcDefaultMemberRoleInput = {
    defaultMemberRoleId: Scalars['ID']['input'];
    oidcIntegrationId: Scalars['ID']['input'];
};
export type UpdateOidcIntegrationInput = {
    authorizationEndpoint?: InputMaybe<Scalars['String']['input']>;
    clientId?: InputMaybe<Scalars['ID']['input']>;
    clientSecret?: InputMaybe<Scalars['String']['input']>;
    oidcIntegrationId: Scalars['ID']['input'];
    tokenEndpoint?: InputMaybe<Scalars['String']['input']>;
    userinfoEndpoint?: InputMaybe<Scalars['String']['input']>;
};
export type UpdateOidcRestrictionsInput = {
    oidcIntegrationId: Scalars['ID']['input'];
    /**
     * Applies only to newly invited members.
     * Existing members are not affected.
     */
    oidcUserAccessOnly: Scalars['Boolean']['input'];
};
export type UpdateOrganizationSlugInput = {
    organizationSlug: Scalars['String']['input'];
    slug: Scalars['String']['input'];
};
export type UpdatePreflightScriptInput = {
    selector: TargetSelectorInput;
    sourceCode: Scalars['String']['input'];
};
export type UpdateProjectGitRepositoryInput = {
    gitRepository?: InputMaybe<Scalars['String']['input']>;
    organizationSlug: Scalars['String']['input'];
    projectSlug: Scalars['String']['input'];
};
export type UpdateProjectSlugInput = {
    project: ProjectReferenceInput;
    slug: Scalars['String']['input'];
};
export type UpdateTargetConditionalBreakingChangeConfigurationInput = {
    /** Updates to the conditional breaking change configuration. */
    conditionalBreakingChangeConfiguration: ConditionalBreakingChangeConfigurationInput;
    /** The target on which the settings are adjusted. */
    target: TargetReferenceInput;
};
export type UpdateTargetDangerousChangeClassificationInput = {
    failDiffOnDangerousChange: Scalars['Boolean']['input'];
    target: TargetReferenceInput;
};
export type UpdateTargetGraphQlEndpointUrlInput = {
    graphqlEndpointUrl?: InputMaybe<Scalars['String']['input']>;
    target: TargetReferenceInput;
};
export type UpdateTargetSlugInput = {
    slug: Scalars['String']['input'];
    target: TargetReferenceInput;
};
export type UpgradeToProInput = {
    couponCode?: InputMaybe<Scalars['String']['input']>;
    monthlyLimits: RateLimitInput;
    organization: OrganizationSelectorInput;
    paymentMethodId?: InputMaybe<Scalars['String']['input']>;
};
export type UsageEstimationInput = {
    month: Scalars['Int']['input'];
    organizationSlug: Scalars['String']['input'];
    year: Scalars['Int']['input'];
};
export declare enum UsageRateLimitType {
    MonthlyLimited = "MONTHLY_LIMITED",
    MonthlyQuota = "MONTHLY_QUOTA",
    Unlimited = "UNLIMITED"
}
export type WebhookChannelInput = {
    endpoint: Scalars['String']['input'];
};
export type MyTokenInfoQueryVariables = Exact<{
    [key: string]: never;
}>;
export type MyTokenInfoQuery = {
    __typename?: 'Query';
    tokenInfo: {
        __typename: 'TokenInfo';
        canReportSchema: boolean;
        canCollectUsage: boolean;
        canReadOperations: boolean;
        token: {
            __typename?: 'Token';
            name: string;
        };
        organization: {
            __typename?: 'Organization';
            slug: string;
        };
        project: {
            __typename?: 'Project';
            type: ProjectType;
            slug: string;
        };
        target: {
            __typename?: 'Target';
            slug: string;
        };
    } | {
        __typename: 'TokenNotFoundError';
        message: string;
    };
};
export type SchemaPublishMutationVariables = Exact<{
    input: SchemaPublishInput;
}>;
export type SchemaPublishMutation = {
    __typename?: 'Mutation';
    schemaPublish: {
        __typename: 'GitHubSchemaPublishError';
    } | {
        __typename: 'GitHubSchemaPublishSuccess';
    } | {
        __typename: 'SchemaPublishError';
        valid: boolean;
        errors: {
            __typename?: 'SchemaErrorConnection';
            total: number;
            nodes: Array<{
                __typename?: 'SchemaError';
                message: string;
            }>;
        };
    } | {
        __typename: 'SchemaPublishMissingServiceError';
        missingServiceError: string;
    } | {
        __typename: 'SchemaPublishMissingUrlError';
        missingUrlError: string;
    } | {
        __typename: 'SchemaPublishRetry';
    } | {
        __typename: 'SchemaPublishSuccess';
        initial: boolean;
        valid: boolean;
        successMessage?: string | null;
    };
};
//# sourceMappingURL=types.d.ts.map