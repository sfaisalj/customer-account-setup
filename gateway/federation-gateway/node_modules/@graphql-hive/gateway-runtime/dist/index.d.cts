import { MaybePromise as MaybePromise$1 } from '@whatwg-node/promise-helpers';
import { OperationTypeNode, FieldNode, TypeInfo, GraphQLNamedOutputType, GraphQLSchema, DocumentNode } from 'graphql';
import { Plugin, YogaInitialContext, Instrumentation as Instrumentation$1, YogaServerOptions, BatchingOptions, FetchAPI as FetchAPI$1, YogaMaskedErrorOpts, YogaServerInstance } from 'graphql-yoga';
import { Plugin as Plugin$1 } from '@envelop/core';
export { withState } from '@envelop/core';
import { useGenericAuth } from '@envelop/generic-auth';
export { ResolveUserFn, ValidateUserFn } from '@envelop/generic-auth';
import { HivePubSub } from '@graphql-hive/pubsub';
import { UnifiedGraphManagerOptions, UnifiedGraphPlugin, Instrumentation as Instrumentation$2, Transports, TransportEntryAdditions, OnSubgraphExecuteHook } from '@graphql-mesh/fusion-runtime';
export { TransportEntryAdditions, getExecutorForUnifiedGraph, getSdkRequesterForUnifiedGraph } from '@graphql-mesh/fusion-runtime';
import { HMACUpstreamSignatureOptions } from '@graphql-mesh/hmac-upstream-signature';
export * from '@graphql-mesh/hmac-upstream-signature';
import { ResponseCacheConfig } from '@graphql-mesh/plugin-response-cache';
import { OnFetchHookPayload, MeshFetch, Logger, KeyValueCache, OnFetchHook } from '@graphql-mesh/types';
import { FetchInstrumentation, LogLevel, DefaultLogger } from '@graphql-mesh/utils';
export { DefaultLogger, LogLevel } from '@graphql-mesh/utils';
import { HTTPExecutorOptions } from '@graphql-tools/executor-http';
import { ExecutionRequest, MaybeAsyncIterable, ExecutionResult, MaybePromise, ValidationRule, TypeSource, IResolvers, Executor } from '@graphql-tools/utils';
import { CSRFPreventionPluginOptions } from '@graphql-yoga/plugin-csrf-prevention';
import { UsePersistedOperationsOptions } from '@graphql-yoga/plugin-persisted-operations';
import { Agent } from 'node:http';
import { Agent as Agent$1 } from 'node:https';
import { HivePluginOptions } from '@graphql-hive/core';
import { FetchAPI } from '@whatwg-node/server';
import { JSONLogger } from '@graphql-hive/logger-json';
export { JSONLogger } from '@graphql-hive/logger-json';
export * from '@whatwg-node/disposablestack';
import { Context, ConnectionInitMessage, ServerOptions } from 'graphql-ws';

type UnifiedGraphSchema = Awaited<ReturnType<UnifiedGraphManagerOptions<unknown>['getUnifiedGraph']>>;
type UnifiedGraphConfig = UnifiedGraphSchema | Promise<UnifiedGraphSchema> | ((configContext: GatewayConfigContext) => UnifiedGraphSchema | Promise<UnifiedGraphSchema>);

interface UseContentEncodingOpts {
    subgraphs?: string[];
}

type AgentFactory<TContext> = (payload: OnFetchHookPayload<Partial<TContext> & GatewayContext & Record<string, any>>) => Agent | Agent$1 | false | undefined;

interface DemandControlPluginOptions {
    /**
     * 	The maximum cost of an accepted operation. An operation with a higher cost than this is rejected.
     *  If not provided, no maximum cost is enforced.
     *  @default Infinity
     */
    maxCost?: number;
    /**
     * The assumed maximum size of a list for fields that return lists.
     * @default 0
     */
    listSize?: number;
    /**
     * Cost based on the operation type.
     * By default, mutations have a cost of 10, queries and subscriptions have a cost of 0.
     * @default ((operationType) => operationType === 'mutation' ? 10 : 0)
     */
    operationTypeCost?(operationType: OperationTypeNode): number;
    /**
     * Cost based on a field
     * It is called for each field in the operation, and overrides the `@cost` directive.
     */
    fieldCost?(fieldNode: FieldNode, typeInfo: TypeInfo): number;
    /**
     * Cost based on a type
     * It is called for return types of fields in the operation, and overrides the `@cost` directive.
     *
     * @default ((type) => isCompositeType(type) ? 1 : 0)
     */
    typeCost?(type: GraphQLNamedOutputType): number;
    /**
     * Include extension values that provide useful information, such as the estimated cost of the operation.
     * Defaults to `true` if `env.NODE_ENV` is set to `"development"`, otherwise `false`.
     */
    includeExtensionMetadata?: boolean;
}

interface HiveConsolePluginOptions extends Omit<HivePluginOptions, 'usage'> {
    usage?: HiveConsoleUsagePluginOptions | boolean | undefined;
}
interface HiveConsoleUsagePluginOptions extends Omit<HiveUsagePluginOptions, 'clientInfo'> {
    /**
     * Extract client info from the GraphQL Context.
     */
    clientInfo?: HiveConsoleUsageClientInfo | ((context: any) => null | undefined | HiveConsoleUsageClientInfo);
}
interface HiveConsoleUsageClientInfo {
    name: string;
    version: string;
}
type HiveUsagePluginOptions = Extract<HivePluginOptions['usage'], object>;

interface FromClientToSubgraphsPayload {
    request: Request;
    subgraphName: string;
}
interface FromSubgraphsToClientPayload {
    response: Response;
    subgraphName: string;
}
interface PropagateHeadersOpts {
    fromClientToSubgraphs?: (payload: FromClientToSubgraphsPayload) => Record<string, string | null | undefined> | void | Promise<Record<string, string | null | undefined> | void>;
    fromSubgraphsToClient?: (payload: FromSubgraphsToClientPayload) => Record<string, string | string[] | null | undefined> | void | Promise<Record<string, string | string[] | null | undefined> | void>;
}
declare function usePropagateHeaders<TContext extends Record<string, any>>(opts: PropagateHeadersOpts): GatewayPlugin<TContext>;

interface GenerateRequestIdPayload<TContext> {
    request: Request;
    fetchAPI: FetchAPI;
    context: TContext & GatewayContext;
}
interface RequestIdOptions<TContext> {
    /**
     * Function to generate a request ID
     *
     * Ignored when `headerName` is available in the request headers
     */
    generateRequestId?: GenerateRequestIdFn<TContext>;
    /**
     * Header name to use for request ID
     *
     * Default: `x-request-id`
     */
    headerName?: string;
}
type GenerateRequestIdFn<TContext> = (payload: GenerateRequestIdPayload<TContext>) => string;

interface SubgraphErrorPluginOptions {
    /**
     * The error code for the error that occurred in the subgraph.
     *
     * If set to `false`, the error code will not be included in the error.
     *
     * @default 'DOWNSTREAM_SERVICE_ERROR'
     */
    errorCode?: string | false;
    /**
     * The name of the extension field for the name of the subgraph
     *
     * If set to `false`, the subgraph name will not be included in the error.
     *
     * @default 'serviceName'
     */
    subgraphNameProp?: string | false;
}

interface UpstreamRetryOptions {
    /**
     * The maximum number of retries to attempt.
     */
    maxRetries: number;
    /**
     * The minimum delay between retries in milliseconds, but this will be increased on each attempt.
     * If the upstream returns `Retry-After` header, the delay will be the value of the header.
     * @default 1000
     */
    retryDelay?: number;
    /**
     * Factor to increase the delay between retries.
     *
     * @default 1.25
     */
    retryDelayFactor?: number;
    /**
     * A function that determines whether a response should be retried.
     * If the upstream returns `Retry-After` header, the response will be retried.
     * By default, it retries on network errors, rate limiting, and non-original GraphQL errors.
     */
    shouldRetry?: (payload: ShouldRetryPayload) => boolean;
}
interface ShouldRetryPayload {
    executionRequest: ExecutionRequest;
    executionResult: MaybeAsyncIterable<ExecutionResult>;
    response?: Response;
}
interface UpstreamRetryPayload {
    subgraphName: string;
    executionRequest: ExecutionRequest;
}
type UpstreamRetryPluginOptions = UpstreamRetryOptions | ((payload: UpstreamRetryPayload) => UpstreamRetryOptions | undefined);
declare function useUpstreamRetry<TContext extends Record<string, any>>(opts: UpstreamRetryPluginOptions): GatewayPlugin<TContext>;

interface TimeoutFactoryPayload {
    subgraphName?: string;
    executionRequest?: ExecutionRequest;
}
type UpstreamTimeoutPluginOptions = number | ((payload: TimeoutFactoryPayload) => number | undefined);
declare function useUpstreamTimeout<TContext extends Record<string, any>>(opts: UpstreamTimeoutPluginOptions): GatewayPlugin<TContext>;

type GatewayConfig<TContext extends Record<string, any> = Record<string, any>> = GatewayConfigSupergraph<TContext> | GatewayConfigSubgraph<TContext> | GatewayConfigProxy<TContext>;
interface GatewayConfigContext {
    /**
     * WHATWG compatible Fetch implementation.
     */
    fetch: MeshFetch;
    /**
     * The logger to use throught Mesh and it's plugins.
     */
    logger: Logger;
    /**
     * Current working directory.
     */
    cwd: string;
    /**
     * Event bus for pub/sub.
     */
    pubsub?: HivePubSub;
    /**
     * Cache Storage
     */
    cache?: KeyValueCache;
}
interface GatewayContext extends GatewayConfigContext, YogaInitialContext {
    /**
     * Environment agnostic HTTP headers provided with the request.
     */
    headers: Record<string, string>;
    /**
     * Runtime context available within WebSocket connections.
     */
    connectionParams: Record<string, string>;
}
type GatewayPlugin<TPluginContext extends Record<string, any> = Record<string, any>, TContext extends Record<string, any> = Record<string, any>> = Plugin<Partial<TPluginContext> & GatewayContext & TContext> & UnifiedGraphPlugin<Partial<TPluginContext> & GatewayContext & TContext> & {
    onFetch?: OnFetchHook<Partial<TPluginContext> & GatewayContext & TContext>;
    onCacheGet?: OnCacheGetHook;
    onCacheSet?: OnCacheSetHook;
    onCacheDelete?: OnCacheDeleteHook;
    /**
     * An Instrumentation instance that will wrap each phases of the request pipeline.
     * This should be used primarily as an observability tool (for monitoring, tracing, etc...).
     *
     * Note: The wrapped functions in instrumentation should always be called. Use hooks to
     *       conditionally skip a phase.
     */
    instrumentation?: Instrumentation<TPluginContext & TContext & GatewayContext>;
};
type OnCacheGetHook = (payload: OnCacheGetHookEventPayload) => MaybePromise<OnCacheGetHookResult | void>;
interface OnCacheGetHookEventPayload {
    cache: KeyValueCache;
    key: string;
    ttl?: number;
}
interface OnCacheGetHookResult {
    onCacheHit?: OnCacheHitHook;
    onCacheMiss?: OnCacheMissHook;
    onCacheGetError?: OnCacheErrorHook;
}
type OnCacheErrorHook = (payload: OnCacheErrorHookPayload) => void;
interface OnCacheErrorHookPayload {
    error: Error;
}
type OnCacheHitHook = (payload: OnCacheHitHookEventPayload) => void;
interface OnCacheHitHookEventPayload {
    value: any;
}
type OnCacheMissHook = () => void;
type OnCacheSetHook = (payload: OnCacheSetHookEventPayload) => MaybePromise<OnCacheSetHookResult | void>;
interface OnCacheSetHookResult {
    onCacheSetDone?: () => void;
    onCacheSetError?: OnCacheErrorHook;
}
interface OnCacheSetHookEventPayload {
    cache: KeyValueCache;
    key: string;
    value: any;
    ttl?: number;
}
type OnCacheDeleteHook = (payload: OnCacheDeleteHookEventPayload) => MaybePromise<OnCacheDeleteHookResult | void>;
interface OnCacheDeleteHookResult {
    onCacheDeleteDone?: () => void;
    onCacheDeleteError?: OnCacheErrorHook;
}
interface OnCacheDeleteHookEventPayload {
    cache: KeyValueCache;
    key: string;
}
type Instrumentation<TContext extends Record<string, any>> = Instrumentation$1<TContext> & Instrumentation$2 & FetchInstrumentation;
interface GatewayConfigSupergraph<TContext extends Record<string, any> = Record<string, any>> extends GatewayConfigSchemaBase<TContext> {
    /**
     * SDL, path or an URL to the Federation Supergraph schema.
     *
     * Alternatively, CDN options for pulling a remote Federation Supergraph.
     */
    supergraph: UnifiedGraphConfig | GatewayHiveCDNOptions | GatewayGraphOSManagedFederationOptions;
    /**
     * GraphQL schema polling interval in milliseconds when the {@link supergraph} is an URL.
     *
     * If {@link cache} is provided, the fetched {@link supergraph} will be cached setting the TTL to this interval in seconds.
     */
    pollingInterval?: number;
}
interface GatewayConfigSubgraph<TContext extends Record<string, any> = Record<string, any>> extends GatewayConfigSchemaBase<TContext> {
    /**
     * SDL, path or an URL to the Federation Subgraph schema.
     */
    subgraph: UnifiedGraphConfig;
}
interface GatewayConfigSchemaBase<TContext extends Record<string, any>> extends GatewayConfigBase<TContext> {
    /**
     * Additional GraphQL schema type definitions.
     */
    additionalTypeDefs?: TypeSource;
    /**
     * Additional GraphQL schema resolvers.
     */
    additionalResolvers?: (IResolvers<unknown, GatewayContext & TContext> | IResolvers<unknown, GatewayContext>) | (IResolvers<unknown, GatewayContext & TContext> | IResolvers<unknown, GatewayContext>)[];
}
interface GatewayConfigProxy<TContext extends Record<string, any> = Record<string, any>> extends GatewayConfigBase<TContext> {
    /**
     * HTTP executor to proxy all incoming requests to another HTTP endpoint.
     */
    proxy: HTTPExecutorOptions & {
        endpoint: string;
    };
    /**
     * SDL, path or an URL to the GraphQL schema.
     *
     * Alternatively, CDN options for pulling a remote GraphQL schema.
     */
    schema?: GraphQLSchema | DocumentNode | string | GatewayHiveCDNOptions;
    /**
     * GraphQL schema polling interval in milliseconds.
     */
    pollingInterval?: number;
    /**
     * Disable GraphQL validation on the gateway
     *
     * By default, the gateway will validate the query against the schema before sending it to the executor.
     * This is recommended to be enabled, but can be disabled for performance reasons.
     *
     * @default false
     */
    skipValidation?: boolean;
}
interface GatewayHiveCDNOptions {
    type: 'hive';
    /**
     * GraphQL Hive CDN endpoint URL.
     */
    endpoint: string;
    /**
     * GraphQL Hive CDN access key.
     */
    key: string;
}
interface GatewayHiveReportingOptions extends Omit<HiveConsolePluginOptions, 'experimental__persistedDocuments'> {
    type: 'hive';
    /** GraphQL Hive registry access token. */
    token: string;
    /** The target to which the usage data should be reported to. */
    target?: string;
}
interface GatewayGraphOSOptions {
    type: 'graphos';
    /**
     * The graph ref of the managed federation graph.
     * It is composed of the graph ID and the variant (`<YOUR_GRAPH_ID>@<VARIANT>`).
     *
     * You can find a a graph's ref at the top of its Schema Reference page in Apollo Studio.
     */
    graphRef: string;
    /**
     * The API key to use to authenticate with the managed federation up link.
     * It needs at least the `service:read` permission.
     *
     * [Learn how to create an API key](https://www.apollographql.com/docs/federation/v1/managed-federation/setup#4-connect-the-gateway-to-studio)
     */
    apiKey: string;
}
interface GatewayGraphOSManagedFederationOptions extends GatewayGraphOSOptions {
    /**
     * Maximum number of retries to attempt when fetching the schema from the managed federation up link.
     */
    maxRetries?: number;
    /**
     * Minimum delay in seconds
     */
    minDelaySeconds?: number;
    /**
     * Delay of seconds on retries
     */
    retryDelaySeconds?: number;
    /**
     * The URL of the managed federation up link. When retrying after a failure, you should cycle through the default up links using this option.
     *
     * Uplinks are available in `DEFAULT_UPLINKS` constant.
     *
     * This options can also be defined using the `APOLLO_SCHEMA_CONFIG_DELIVERY_ENDPOINT` environment variable.
     * It should be a comma separated list of up links, but only the first one will be used.
     *
     * Default: 'https://uplink.api.apollographql.com/' (Apollo's managed federation up link on GCP)
     *
     * Alternative: 'https://aws.uplink.api.apollographql.com/' (Apollo's managed federation up link on AWS)
     */
    upLink?: string;
    /**
     * Agent Version to report to the usage reporting API
     *
     * @default "hive-gateway@VERSION_OF_GW"
     */
    agentVersion?: string;
    /**
     * Client name to report to the usage reporting API
     *
     * @default incoming `apollo-graphql-client-name` HTTP header
     */
    clientName?(req: Request): MaybePromise<string>;
    /**
     * Client version to report to the usage reporting API
     *
     * @default incoming `apollo-graphql-client-version` HTTP header
     */
    clientVersion?(req: Request): MaybePromise<string>;
}
interface GatewayGraphOSReportingOptions extends GatewayGraphOSOptions {
    /**
     * Usage report endpoint
     *
     * Defaults to GraphOS endpoint (https://usage-reporting.api.apollographql.com/api/ingress/traces)
     */
    endpoint?: string;
}
/**
 * Use Hive's CDN for persisted documents.
 *
 * [See more.](https://the-guild.dev/graphql/hive/docs/features/app-deployments#persisted-documents-on-graphql-server-and-gateway)
 * */
interface GatewayHivePersistedDocumentsOptions {
    type: 'hive';
    /**
     * GraphQL Hive persisted documents CDN endpoint URL.
     */
    endpoint: string;
    /**
     * GraphQL Hive persisted documents CDN access token.
     */
    token: string;
    /**
     * Whether arbitrary documents should be allowed along-side persisted documents.
     *
     * Alternatively, you can provide a function that returns a boolean value based on
     * the request's headers.
     *
     * @default false
     */
    allowArbitraryDocuments?: boolean | ((request: Request) => MaybePromise<boolean>);
}
interface GatewayConfigBase<TContext extends Record<string, any>> {
    /** Usage reporting options. */
    reporting?: GatewayHiveReportingOptions | GatewayGraphOSReportingOptions;
    /** Persisted documents options. */
    persistedDocuments?: GatewayHivePersistedDocumentsOptions | UsePersistedOperationsOptions<GatewayContext>;
    /**
     * A map, or factory function, of transport kinds to their implementations.
     *
     * @example Providing a module exporting a transport.
     *
     * ```ts
     * import { defineConfig } from '@graphql-hive/gateway';
     *
     * export const gatewayConfig = defineConfig({
     *   transports: {
     *     http: import('@graphql-mesh/transport-http'),
     *   },
     * });
     * ```
     */
    transports?: Transports;
    /**
     * Configure Transport options for each subgraph.
     *
     * @example Adding subscriptions support for Federation v2 subgraphs.
     *
     * ```ts
     * import { defineConfig } from '@graphql-hive/gateway';
     *
     * export const gatewayConfig = defineConfig({
     *   transportEntries: {
     *     '*': {
     *       http: {
     *          options: {
     *            subscriptions: {
     *              ws: {
     *                endpoint: '/subscriptions',
     *              },
     *          },
     *         },
     *       },
     *     },
     *   },
     * });
     * ```
     */
    transportEntries?: TransportEntryAdditions;
    /**
     * Gateway plugins that are compatible with GraphQL Yoga, envelop and Mesh.
     */
    plugins?(context: GatewayConfigContext): (Plugin$1 | Plugin$1<GatewayContext> | Plugin$1<GatewayContext & TContext> | Plugin | Plugin<GatewayContext> | Plugin<GatewayContext & TContext> | GatewayPlugin | GatewayPlugin<any, GatewayContext> | GatewayPlugin<any, GatewayContext & TContext>)[];
    /**
     * Enable, disable or configure CORS.
     */
    cors?: YogaServerOptions<unknown, GatewayContext & TContext>['cors'];
    /**
     * Show, hide or configure GraphiQL.
     */
    graphiql?: YogaServerOptions<unknown, GatewayContext & TContext>['graphiql'];
    /**
     * Accepts a factory function that returns GraphiQL HTML, this replaces the existing GraphiQL
     * So this option can be also used to provide an offline GraphiQL
     * @see https://the-guild.dev/graphql/yoga-server/docs/features/graphiql#offline-usage
     */
    renderGraphiQL?: YogaServerOptions<unknown, GatewayContext & TContext>['renderGraphiQL'];
    /**
     * Whether the landing page should be shown.
     */
    landingPage?: boolean;
    /**
     * Enable and define a limit for [Request Batching](https://github.com/graphql/graphql-over-http/blob/main/rfcs/Batching.md).
     */
    batching?: BatchingOptions;
    /**
     * WHATWG compatible Fetch implementation.
     *
     * If you want to change the fetch function implementation, use `useCustomFetch` plugin.
     * But we do not recommend changing the fetch implementation unless you know what you are doing.
     *
     * @warning Do not use this option unless you know what you are doing.
     */
    fetchAPI?: Partial<Omit<FetchAPI$1, 'fetch'> & {
        fetch?: MeshFetch;
    }>;
    /**
     * Enable, disable or implement a custom logger for logging.
     *
     * @default true
     * @see https://the-guild.dev/graphql/hive/docs/gateway/logging-and-error-handling
     */
    logging?: boolean | Logger | LogLevel | keyof typeof LogLevel | undefined;
    /**
     * Endpoint of the GraphQL API.
     */
    graphqlEndpoint?: string;
    /**
     * Configure error masking for more control over the exposed errors.
     *
     * Throwing `EnvelopError` or `GraphQLError`s within your GraphQL resolvers exposes the full error to the client through a well-formatted GraphQL response.
     *
     * @see https://the-guild.dev/graphql/yoga-server/docs/features/error-masking
     *
     * @default true
     */
    maskedErrors?: boolean | Partial<YogaMaskedErrorOpts>;
    /**
     * Cache storage interface for various operations that can get cached.
     *
     * For example, the fetched {@link supergraph} will be cached setting the TTL to the provided polling interval in seconds when it's behind and URL.
     */
    cache?: KeyValueCache;
    pubsub?: HivePubSub;
    /**
     * Health check endpoint
     */
    healthCheckEndpoint?: string;
    /**
     * Readiness check endpoint
     */
    readinessCheckEndpoint?: string;
    /**
     * Working directory to run Hive Gateway with.
     */
    cwd?: string;
    /**
     * The name of the product.
     *
     * @default 'GraphQL Mesh'
     */
    productName?: string;
    /**
     * The description of the product.
     *
     * @default 'serve GraphQL federated architecture for any API service(s)'
     */
    productDescription?: string;
    /**
     * The name of the package.
     *
     * @default '@graphql-hive/gateway'
     */
    productPackageName?: string;
    /**
     * The logo of the product.
     */
    productLogo?: string;
    /**
     * The link to the product website
     */
    productLink?: string;
    /**
     * Enable response caching
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/other-features/performance/response-caching)
     */
    responseCaching?: Omit<ResponseCacheConfig, keyof GatewayConfigContext>;
    /**
     * Enable compression and decompression of HTTP requests and responses
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/other-features/performance/compression)
     */
    contentEncoding?: boolean | UseContentEncodingOpts;
    /**
     * Enable `@defer` and `@stream` support
     *
     * @experimental This feature is experimental and may change in the future.
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/defer-stream)
     */
    deferStream?: boolean;
    /**
     * Enable execution cancellation
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/other-features/performance/execution-cancellation)
     */
    executionCancellation?: boolean;
    /**
     * Enable upstream cancellation
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/other-features/performance/upstream-cancellation)
     */
    upstreamCancellation?: boolean;
    /**
     * Disable introspection
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/other-features/security/disable-introspection)
     *
     * @default false
     */
    disableIntrospection?: DisableIntrospectionOptions;
    /**
     * CSRF Prevention
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/other-features/security/csrf-prevention)
     */
    csrfPrevention?: CSRFPreventionPluginOptions;
    /**
     * Providing a custom HTTP(S) Agent to manipulate the HTTP(S) requests.
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/other-features/security/https)
     */
    customAgent?: AgentFactory<GatewayContext & TContext>;
    /**
     * Generic Auth Configuration
     */
    genericAuth?: Parameters<typeof useGenericAuth>[0];
    /**
     * HMAC Signature Handling
     *
     * [Learn more](https://graphql-hive.com/docs/gateway/other-features/security/hmac-signature)
     */
    hmacSignature?: HMACUpstreamSignatureOptions;
    /**
     * Enable WebHooks handling
     */
    webhooks?: boolean;
    /**
     * Header Propagation
     */
    propagateHeaders?: PropagateHeadersOpts;
    /**
     * Upstream Timeout
     *
     * Configure the timeout for upstream requests.
     */
    upstreamTimeout?: UpstreamTimeoutPluginOptions;
    /**
     * Upstream Request Retry
     *
     * Configure the retry for upstream requests.
     */
    upstreamRetry?: UpstreamRetryPluginOptions;
    /**
     * Configure the request ID for the gateway
     *
     * @default true
     */
    requestId?: boolean | RequestIdOptions<TContext>;
    /**
     * Demand Control
     *
     * Configure the demand control for upstream requests.
     */
    demandControl?: DemandControlPluginOptions;
    /**
     * Enable/disable batching the requests to the subgraphs
     *
     * Do not use it unless you know what you are doing.
     *
     * @experimental
     */
    __experimental__batchDelegation?: boolean;
    /**
     * Subgraph error handling
     */
    subgraphErrors?: SubgraphErrorPluginOptions | false;
    /**
     * Process cookie headers
     *
     * Now [`request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object in the GraphQL Context will have [`cookieStore`](https://developer.mozilla.org/en-US/docs/Web/API/CookieStore).
     *
     * This feature flag needs to be enabled for plugins such as:
     * [JWT Plugin with cookies](https://the-guild.dev/graphql/hive/docs/gateway/authorization-authentication#token-lookup)
     *
     * You can learn more about the underlying GraphQL Yoga plugin [here](https://the-guild.dev/graphql/yoga-server/docs/features/cookies)
     */
    cookies?: boolean;
}
interface DisableIntrospectionOptions {
    disableIf?: (args: {
        context: GatewayContext;
        params: ValidateFunctionParameters;
    }) => boolean;
}
interface ValidateFunctionParameters {
    /**
     * GraphQL schema instance.
     */
    schema: GraphQLSchema;
    /**
     * Parsed document node.
     */
    documentAST: DocumentNode;
    /**
     * The rules used for validation.
     * validate uses specifiedRules as exported by the GraphQL module if this parameter is undefined.
     */
    rules?: ValidationRule[];
    /**
     * TypeInfo instance which is used for getting schema information during validation
     */
    typeInfo?: TypeInfo;
    options?: {
        maxErrors?: number;
    };
}

type GatewayRuntime<TContext extends Record<string, any> = Record<string, any>> = YogaServerInstance<any, TContext> & {
    invalidateUnifiedGraph(): void;
    getSchema(): MaybePromise$1<GraphQLSchema>;
};
declare function createGatewayRuntime<TContext extends Record<string, any> = Record<string, any>>(config: GatewayConfig<TContext>): GatewayRuntime<TContext>;

declare function useCustomFetch(fetch: MeshFetch): GatewayPlugin;

interface StaticFilesOpts {
    baseDir: string;
    staticFiles?: string;
}
declare const useStaticFiles: ({ baseDir, staticFiles, }: StaticFilesOpts) => Plugin;

declare function getProxyExecutor<TContext extends Record<string, any>>({ config, configContext, getSchema, onSubgraphExecuteHooks, transportExecutorStack, instrumentation, }: {
    config: GatewayConfigProxy<TContext>;
    configContext: GatewayConfigContext;
    getSchema: () => GraphQLSchema;
    onSubgraphExecuteHooks: OnSubgraphExecuteHook[];
    transportExecutorStack: AsyncDisposableStack;
    instrumentation: () => Instrumentation$2 | undefined;
}): Executor;

declare function getGraphQLWSOptions<TContext extends Record<string, any>, E>(gwRuntime: GatewayRuntime<TContext>, onContext: (ctx: Context<ConnectionInitMessage['payload'], E>) => MaybePromise<Record<string, unknown>>): ServerOptions<ConnectionInitMessage['payload'], E>;

declare function getDefaultLogger(opts?: {
    name?: string;
    level?: LogLevel;
}): JSONLogger | DefaultLogger;
declare function handleLoggingConfig(loggingConfig: boolean | Logger | LogLevel | keyof typeof LogLevel | undefined, existingLogger?: Logger): Logger;

export { type GatewayConfig, type GatewayConfigContext, type GatewayConfigProxy, type GatewayConfigSubgraph, type GatewayConfigSupergraph, type GatewayContext, type GatewayGraphOSManagedFederationOptions, type GatewayGraphOSOptions, type GatewayGraphOSReportingOptions, type GatewayHiveCDNOptions, type GatewayHivePersistedDocumentsOptions, type GatewayHiveReportingOptions, type GatewayPlugin, type GatewayRuntime, type Instrumentation, type OnCacheDeleteHook, type OnCacheDeleteHookEventPayload, type OnCacheDeleteHookResult, type OnCacheErrorHook, type OnCacheErrorHookPayload, type OnCacheGetHook, type OnCacheGetHookEventPayload, type OnCacheGetHookResult, type OnCacheHitHook, type OnCacheHitHookEventPayload, type OnCacheMissHook, type OnCacheSetHook, type OnCacheSetHookEventPayload, type OnCacheSetHookResult, type PropagateHeadersOpts, type StaticFilesOpts, type UnifiedGraphConfig, createGatewayRuntime, getDefaultLogger, getGraphQLWSOptions, getProxyExecutor, handleLoggingConfig, useCustomFetch, usePropagateHeaders, useStaticFiles, useUpstreamRetry, useUpstreamTimeout };
